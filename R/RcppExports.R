# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

reduce_adj <- function(adj_list, prec_map, n_keep) {
    .Call(`_redist_reduce_adj`, adj_list, prec_map, n_keep)
}

collapse_adj <- function(graph, idxs) {
    .Call(`_redist_collapse_adj`, graph, idxs)
}

coarsen_adjacency <- function(adj, groups) {
    .Call(`_redist_coarsen_adjacency`, adj, groups)
}

get_plan_graph <- function(l, V, plan, n_distr) {
    .Call(`_redist_get_plan_graph`, l, V, plan, n_distr)
}

color_graph <- function(l, plan) {
    .Call(`_redist_color_graph`, l, plan)
}

polsbypopper <- function(from, to, area, perimeter, dm, nd) {
    .Call(`_redist_polsbypopper`, from, to, area, perimeter, dm, nd)
}

genAlConn <- function(aList, cds) {
    .Call(`_redist_genAlConn`, aList, cds)
}

findBoundary <- function(fullList, conList) {
    .Call(`_redist_findBoundary`, fullList, conList)
}

contiguity <- function(adj, group) {
    .Call(`_redist_contiguity`, adj, group)
}

cores <- function(adj, dm, k, cd_within_k) {
    .Call(`_redist_cores`, adj, dm, k, cd_within_k)
}

update_conncomp <- function(dm, kvec, adj) {
    .Call(`_redist_update_conncomp`, dm, kvec, adj)
}

crsg <- function(adj_list, population, area, x_center, y_center, Ndistrict, target_pop, thresh, maxiter) {
    .Call(`_redist_crsg`, adj_list, population, area, x_center, y_center, Ndistrict, target_pop, thresh, maxiter)
}

dist_dist_diff <- function(p, i_dist, j_dist, x_center, y_center, x, y) {
    .Call(`_redist_dist_dist_diff`, p, i_dist, j_dist, x_center, y_center, x, y)
}

log_st_map <- function(g, districts, counties, n_distr) {
    .Call(`_redist_log_st_map`, g, districts, counties, n_distr)
}

n_removed <- function(g, districts, n_distr) {
    .Call(`_redist_n_removed`, g, districts, n_distr)
}

countpartitions <- function(aList) {
    .Call(`_redist_countpartitions`, aList)
}

calcPWDh <- function(x) {
    .Call(`_redist_calcPWDh`, x)
}

group_pct_top_k <- function(m, group_pop, total_pop, k, n_distr) {
    .Call(`_redist_group_pct_top_k`, m, group_pop, total_pop, k, n_distr)
}

proj_distr_m <- function(districts, x, draw_idx, n_distr) {
    .Call(`_redist_proj_distr_m`, districts, x, draw_idx, n_distr)
}

colmax <- function(x) {
    .Call(`_redist_colmax`, x)
}

colmin <- function(x) {
    .Call(`_redist_colmin`, x)
}

prec_cooccur <- function(m, idxs, ncores = 0L) {
    .Call(`_redist_prec_cooccur`, m, idxs, ncores)
}

group_pct <- function(m, group_pop, total_pop, n_distr) {
    .Call(`_redist_group_pct`, m, group_pop, total_pop, n_distr)
}

pop_tally <- function(districts, pop, n_distr) {
    .Call(`_redist_pop_tally`, districts, pop, n_distr)
}

max_dev <- function(districts, pop, n_distr) {
    .Call(`_redist_max_dev`, districts, pop, n_distr)
}

ms_plans <- function(N, l, init, counties, pop, n_distr, target, lower, upper, rho, constraints, control, k, thin, verbosity) {
    .Call(`_redist_ms_plans`, N, l, init, counties, pop, n_distr, target, lower, upper, rho, constraints, control, k, thin, verbosity)
}

#' Uses gsmc method with optimal weights to generate a sample of `M` plans in `c++`
#'
#' Using the procedure outlined in <PAPER HERE> this function uses Sequential
#' Monte Carlo (SMC) methods to generate a sample of `M` plans
#'
#' @title Run Optimalgsmc
#'
#' @param N The number of districts the final plans will have
#' @param adj_list A 0-indexed adjacency list representing the undirected graph
#' which represents the underlying map the plans are to be drawn on
#' @param counties Vector of county labels of each vertex in `g`
#' @param pop A vector of the population associated with each vertex in `g`
#' @param target Ideal population of a valid district. This is what deviance is calculated
#' relative to
#' @param lower Acceptable lower bounds on a valid district's population
#' @param upper Acceptable upper bounds on a valid district's population
#' @param M The number of plans (samples) to draw
#' @param k_param The k parameter from the SMC algorithm, you choose among the top k_param edges
#' @param control Named list of additional parameters.
#' @param num_threads The number of threads the threadpool should use
#' @param verbosity What level of detail to print out while the algorithm is
#' running <ADD OPTIONS>
#' @export
optimal_gsmc_plans <- function(N, adj_list, counties, pop, target, lower, upper, M, control, num_threads = -1L, verbosity = 3L, diagnostic_mode = FALSE) {
    .Call(`_redist_optimal_gsmc_plans`, N, adj_list, counties, pop, target, lower, upper, M, control, num_threads, verbosity, diagnostic_mode)
}

pareto_dominated <- function(x) {
    .Call(`_redist_pareto_dominated`, x)
}

testing_sample_forest <- function(l, pop, lower, upper, counties, ignore) {
    .Call(`_redist_testing_sample_forest`, l, pop, lower, upper, counties, ignore)
}

perform_a_valid_region_split_then_merge_split <- function(adj_list, counties, pop, k_param, region_id_to_split, target, lower, upper, N, num_regions, num_districts, region_ids, region_dvals, region_pops, split_district_only, num_merge_split_steps, verbose) {
    .Call(`_redist_perform_a_valid_region_split_then_merge_split`, adj_list, counties, pop, k_param, region_id_to_split, target, lower, upper, N, num_regions, num_districts, region_ids, region_dvals, region_pops, split_district_only, num_merge_split_steps, verbose)
}

one_cut_then_merge_split <- function(N, adj_list, counties, pop, target, lower, upper, split_district_only, num_merge_split_steps, verbose) {
    .Call(`_redist_one_cut_then_merge_split`, N, adj_list, counties, pop, target, lower, upper, split_district_only, num_merge_split_steps, verbose)
}

plan_class_testing <- function(V, num_regions, num_districts) {
    .Call(`_redist_plan_class_testing`, V, num_regions, num_districts)
}

split_entire_map <- function(N, adj_list, counties, pop, target, lower, upper, verbose = FALSE) {
    .Call(`_redist_split_entire_map`, N, adj_list, counties, pop, target, lower, upper, verbose)
}

split_all_the_way <- function(N, adj_list, counties, pop, target, lower, upper, verbose) {
    .Call(`_redist_split_all_the_way`, N, adj_list, counties, pop, target, lower, upper, verbose)
}

copy_semantics_tester_outer <- function() {
    invisible(.Call(`_redist_copy_semantics_tester_outer`))
}

test_cpp_discrete_distribution <- function() {
    invisible(.Call(`_redist_test_cpp_discrete_distribution`))
}

test_region_lev_graph_stuff <- function(N, adj_list, counties, pop, target, lower, upper, verbose) {
    .Call(`_redist_test_region_lev_graph_stuff`, N, adj_list, counties, pop, target, lower, upper, verbose)
}

closest_adj_pop <- function(adj, i_dist, g_prop) {
    .Call(`_redist_closest_adj_pop`, adj, i_dist, g_prop)
}

rint1 <- function(n, max) {
    .Call(`_redist_rint1`, n, max)
}

runif1 <- function(n, max) {
    .Call(`_redist_runif1`, n, max)
}

resample_lowvar <- function(wgts) {
    .Call(`_redist_resample_lowvar`, wgts)
}

plan_joint <- function(m1, m2, pop) {
    .Call(`_redist_plan_joint`, m1, m2, pop)
}

renumber_matrix <- function(plans, renumb) {
    .Call(`_redist_renumber_matrix`, plans, renumb)
}

solve_hungarian <- function(costMatrix) {
    .Call(`_redist_solve_hungarian`, costMatrix)
}

rsg <- function(adj_list, population, Ndistrict, target_pop, thresh, maxiter) {
    .Call(`_redist_rsg`, adj_list, population, Ndistrict, target_pop, thresh, maxiter)
}

k_smallest <- function(x, k = 1L) {
    .Call(`_redist_k_smallest`, x, k)
}

k_biggest <- function(x, k = 1L) {
    .Call(`_redist_k_biggest`, x, k)
}

smc_plans <- function(N, l, counties, pop, n_distr, target, lower, upper, rho, districts, n_drawn, n_steps, constraints, control, verbosity = 1L) {
    .Call(`_redist_smc_plans`, N, l, counties, pop, n_distr, target, lower, upper, rho, districts, n_drawn, n_steps, constraints, control, verbosity)
}

#' Uses gsmc method with optimal weights and merge split steps to generate a sample of `M` plans in `c++`
#'
#' Using the procedure outlined in <PAPER HERE> this function uses Sequential
#' Monte Carlo (SMC) methods to generate a sample of `M` plans
#'
#' @title Run Optimalgsmc with Merge Split
#'
#' @param N The number of districts the final plans will have
#' @param adj_list A 0-indexed adjacency list representing the undirected graph
#' which represents the underlying map the plans are to be drawn on
#' @param counties Vector of county labels of each vertex in `g`
#' @param pop A vector of the population associated with each vertex in `g`
#' @param target Ideal population of a valid district. This is what deviance is calculated
#' relative to
#' @param lower Acceptable lower bounds on a valid district's population
#' @param upper Acceptable upper bounds on a valid district's population
#' @param M The number of plans (samples) to draw
#' @param k_param The k parameter from the SMC algorithm, you choose among the top k_param edges
#' @param control Named list of additional parameters.
#' @param num_threads The number of threads the threadpool should use
#' @param verbosity What level of detail to print out while the algorithm is
#' running <ADD OPTIONS>
#' @export
optimal_gsmc_with_merge_split_plans <- function(N, adj_list, counties, pop, target, lower, upper, M, control, num_threads = -1L, verbosity = 3L, diagnostic_mode = FALSE) {
    .Call(`_redist_optimal_gsmc_with_merge_split_plans`, N, adj_list, counties, pop, target, lower, upper, M, control, num_threads, verbosity, diagnostic_mode)
}

splits <- function(dm, community, nd, max_split) {
    .Call(`_redist_splits`, dm, community, nd, max_split)
}

dist_cty_splits <- function(dm, community, nd) {
    .Call(`_redist_dist_cty_splits`, dm, community, nd)
}

#' Selects a multidistrict with probability proportional to its d_nk value and
#' returns the log probability of the selected region
#'
#' Given a plan object with at least one multidistrict this function randomly
#' selects a multidistrict with probability proporitional to its d_nk value
#' (relative to all multidistricts) and returns the log of the probability that
#' region was chosen.
#'
#'
#' @title Choose multidistrict to split
#'
#' @param plan A plan object
#' @param region_to_split an integer that will be updated by reference with the
#' id number of the region selected to split
#'
#' @details No modifications to inputs made
#'
#' @return the region level graph
#'
#' @noRd
#' @keywords internal
NULL

#' Attempts to cut one region into two from a spanning tree and if successful
#' returns information on what the two new regions would be. Does not actually
#' update the plan
#'
#' Takes a spanning tree `ust` drawn on a specific region and attempts to cut
#' it to produce two new regions using the generalized splitting procedure
#' outlined <PAPER HERE>. This function is based on `cut_districts` in `smc.cpp`
#' however the crucial difference is even if a cut is successful it does not
#' update the plan. Instead it just returns the information on the two new
#' regions if successful and the vertices to use to update the plans.
#'
#' Depending on the value of max_potential_d will only attempt to split off
#' a single district or allows for more general splits.
#'
#' By convention the first new region (`new_region1`) will always be the region
#' with the smaller d-value (although they can be equal).
#'
#' @title Attempt to Cut Region Tree into Two New Regions
#'
#' @param ust A directed spanning tree passed by reference
#' @param root The root vertex of the spanning tree
#' @param k_param The k parameter from the SMC algorithm, you choose among the top k_param edges
#' @param max_potential_d The largest potential d value it will try for a cut. Setting this to 
#' 1 will result in only 1 district splits. 
#' @param pop A vector of the population associated with each vertex in `g`
#' @param region_ids A vector mapping 0 indexed vertices to their region id number
#' @param region_id_to_split The id of the region in the plan object we're attempting to split
#' @param total_region_pop The total population of the region being split 
#' @param total_region_dval The dval of the region being split 
#' @param lower Acceptable lower bounds on a valid district's population
#' @param upper Acceptable upper bounds on a valid district's population
#' @param target Ideal population of a valid district. This is what deviance is calculated
#' relative to
#' @param new_region1_tree_root The index of the root of tree associated with
#' the first new region (if the tree cut was successful)
#' @param new_region1_dval The d-value of the first new region (if the tree cut
#'  was successful)
#' @param new_region1_pop The population of the first new region (if the tree cut
#' was successful)
#' @param new_region2_tree_root The index of the root of tree associated with
#' the second new region (if the tree cut was successful)
#' @param new_region2_dval The d-value of the second new region (if the tree cut
#'  was successful)
#' @param new_region2_pop The population of the second new region (if the tree cut
#' was successful)
#'
#' @details Modifications
#'    - If two new valid regions are split then the tree `ust` is cut into two
#'    distjoint pieces
#'    - If two new valid regions are split then the 6 `new_region` inputs are all
#'    updated by reference with the values associated with the new regions
#'
#' @return True if two valid regions were successfully split, false otherwise
#'
#' @noRd
#' @keywords internal
NULL

#' Updates a `Plan` object using a cut tree
#'
#' Takes a cut spanning tree `ust` and variables on the two new regions
#' induced by the cuts and updates `plan` with information on those two
#' new regions. Assumes that the plan attributes already have the correct
#' size and accessing either of the region ids won't create issues.
#'
#' It also sets `plan.remainder_region` equal to `new_region2_id` if 
#' split_district_only is true. 
#'
#'
#' @title Update plan regions from cut tree
#'
#' @param ust A cut (ie has two partition pieces) directed spanning tree
#' passed by reference
#' @param plan A plan object
#' @param split_district_only Whether or not this was split according to a 
#' one district split scheme (as in does the remainder need to be updated)
#' @param new_region1_tree_root The vertex of the root of one piece of the cut
#' tree. This always corresponds to the region with the smaller dval (allowing
#' for the possiblity the dvals are equal).
#' @param new_region1_dval The dval associated with the new region 1
#' @param new_region1_pop The population associated with the new region 1
#' @param new_region2_tree_root The vertex of the root of other piece of the cut
#' tree. This always corresponds to the region with the bigger dval (allowing
#' for the possiblity the dvals are equal).
#' @param new_region2_dval The dval associated with the new region 2
#' @param new_region2_pop The population associated with the new region 2
#' @param new_region1_id The id the new region 1 was assigned in the plan
#' @param new_region2_id The id the new region 2 was assigned in the plan
#'
#' @details Modifications
#'    - `plan` is updated in place with the two new regions
#'
#' @noRd
#' @keywords internal
NULL

#' Creates new regions and updates the `Plan` object using a cut tree
#'
#' Takes a cut spanning tree `ust` and variables on the two new regions
#' induced by the cuts and creates space/updates the information on those
#' two new regions in the `plan` object. This function increases the number
#' of regions aspect by 1 and updates the region level information and all
#' other variables changed by adding a new region. 
#'
#' It also sets `plan.remainder_region` equal to `new_region2_id` if 
#' split_district_only is true. 
#'
#'
#' @title Create and update new plan regions from cut tree
#'
#' @param ust A cut (ie has two partition pieces) directed spanning tree
#' passed by reference
#' @param plan A plan object
#' @param split_district_only Whether or not this was split according to a 
#' one district split scheme (as in does the remainder need to be updated)
#' @param old_split_region_id The id of the region that was split into the two
#' new ones 
#' @param new_region1_tree_root The vertex of the root of one piece of the cut
#' tree. This always corresponds to the region with the smaller dval (allowing
#' for the possiblity the dvals are equal).
#' @param new_region1_dval The dval associated with the new region 1
#' @param new_region1_pop The population associated with the new region 1
#' @param new_region2_tree_root The vertex of the root of other piece of the cut
#' tree. This always corresponds to the region with the bigger dval (allowing
#' for the possiblity the dvals are equal).
#' @param new_region2_dval The dval associated with the new region 2
#' @param new_region2_pop The population associated with the new region 2
#' @param new_region1_id The id the new region 1 was assigned in the plan
#' @param new_region2_id The id the new region 2 was assigned in the plan
#'
#' @details Modifications
#'    - `plan` is updated in place with the two new regions
#'    - `new_region1_id` is set to the id new region1 was assigned
#'    which is just the `old_split_region_id`
#'    - `new_region2_id` is set to the id new region2 was assigned 
#'    which is just `plan.num_regions-1`
#'
#' @noRd
#' @keywords internal
NULL

#' Splits a multidistrict in all of the plans
#'
#' Using the procedure outlined in <PAPER HERE> this function attempts to split
#' a multidistrict in a previous steps plan until M successful splits have been made. This
#' is based on the `split_maps` function in smc.cpp
#'
#' @title Split all the maps
#'
#' @param g A graph (adjacency list) passed by reference
#' @param counties Vector of county labels of each vertex in `g`
#' @param cg County level multigraph
#' @param pop A vector of the population associated with each vertex in `g`
#' @param old_plans_vec A vector of plans from the previous step
#' @param new_plans_vec A vector which will be filled with plans that had a
#' multidistrict split to make them
#' @param original_ancestor_vec A vector used to track which original ancestor
#' the new plans descended from. The value  of `original_ancestor_vec[i]`
#' is the index of the original ancestor the new plan `new_plans_vec[i]` is
#' descended from.
#' @param parent_vec A vector used to track the index of the previous plan
#' sampled that was successfully split. The value of `parent_vec[i]` is the
#' index of the old plan from which the new plan `new_plans_vec[i]` was
#' successfully split from. In other words `new_plans_vec[i]` is equal to
#' `attempt_region_split(old_plans_vec[parent_vec[i]], ...)`
#' @param prev_ancestor_vec A vector used to track the index of the original
#' ancestor of the previous plans. The value of `prev_ancestor_vec[i]` is the
#' index of the original ancestor of `old_plans_vec[i]`
#' @param unnormalized_sampling_weights A vector of weights used to sample indices
#' of the `old_plans_vec`. The value of `unnormalized_sampling_weights[i]` is
#' the unnormalized probability that index i is selected
#' @param normalized_weights_to_fill_in A vector which will be filled with the
#' normalized weights the index sampler uses. The value of
#' `normalized_weights_to_fill_in[i]` is the probability that index i is selected
#' @param draw_tries_vec A vector used to keep track of how many plan split
#' attempts were made for index i. The value `draw_tries_vec[i]` represents how
#' many split attempts were made for the i-th new plan (including the successful
#' split). For example, `draw_tries_vec[i] = 1` means that the first split
#' attempt was successful.
#' @param parent_unsuccessful_tries_vec A vector used to keep track of how many times the
#' previous rounds plans were sampled and unsuccessfully split. The value
#' `parent_unsuccessful_tries_vec[i]` represents how many times `old_plans_vec[i]` was sampled
#' and then unsuccessfully split while creating all `M` of the new plans.
#' THIS MAY NOT BE THREAD SAFE
#' @param accept_rate The number of accepted splits over the total number of
#' attempted splits. This is equal to `sum(draw_tries_vec)/M`
#' @param n_unique_parent_indices The number of unique parent indices, ie the
#' number of previous plans that had at least one descendant amongst the new
#' plans. This is equal to `unique(parent_vec)`
#' @param n_unique_original_ancestors The number of unique original ancestors,
#' in the new plans. This is equal to `unique(original_ancestor_vec)`
#' @param ancestors Parameter from older `smc.cpp` code. I DON'T UNDERSTAND
#' WHAT IT IS DOING
#' @param lags Parameter from older `smc.cpp` code. I DON'T UNDERSTAND
#' WHAT IT IS DOING
#' @param lower Acceptable lower bounds on a valid district's population
#' @param upper Acceptable upper bounds on a valid district's population
#' @param target Ideal population of a valid district. This is what deviance is calculated
#' relative to
#' @param k_param The top edges to pick parameter for the region splitting
#' algorithm
#' @param split_district_only Whether or not to only allow for single district
#' splits. If set to `true` will only attempt to split off one district at a
#' time
#' @param pool A threadpool for multithreading
#' @param verbosity A parameter controlling the amount of detail printed out
#' during the algorithms running
#'
#' @details Modifications
#'    - The `new_plans_vec` is updated with all the newly split plans
#'    - The `old_plans_vec` is updated with all the newly split plans as well.
#'    Note that the reason both this and `new_plans_vec` are updated is because
#'    of the nature of the code you need both vectors and so both are passed by
#'    reference to save memory.
#'    - The `original_ancestor_vec` is updated to contain the indices of the
#'    original ancestors of the new plans
#'    - The `parent_vec` is updated to contain the indices of the parents of the
NULL

#'    - If two new valid regions are split then the new_region_ids is updated so the
#'    first entry is the first new region and the second entry is the second new region
#'    - The `normalized_weights_to_fill_in` is updated to contain the normalized
#'    probabilities the index sampler used. This is only collected for diagnostics
#'    at this point and should just be equal to `unnormalized_sampling_weights`
#'    divided by `sum(unnormalized_sampling_weights)`
#'    - The `draw_tries_vec` is updated to contain the number of tries for each
#'    of the new plans
#'    - The `parent_unsuccessful_tries_vec` is updated to contain the number of unsuccessful
#'    samples of the old plans
#'    - The `accept_rate` is updated to contain the average acceptance rate for
#'    this iteration
#'    - `n_unique_parent_indices` and `n_unique_original_ancestors` are updated
#'    with the unique number of parents and original ancestors for all the new
#'    plans respectively
#'    - `ancestors` is updated to something. THIS IS FROM ORIGINAL SMC CODE,
#'    I DO NOT KNOW WHAT IT MEANS
#'
#' @return nothing
#'
#' @noRd
#' @keywords internal
NULL

perform_a_valid_region_split <- function(adj_list, counties, pop, k_param, region_id_to_split, target, lower, upper, N, num_regions, num_districts, region_ids, region_dvals, region_pops, split_district_only, verbose) {
    .Call(`_redist_perform_a_valid_region_split`, adj_list, counties, pop, k_param, region_id_to_split, target, lower, upper, N, num_regions, num_districts, region_ids, region_dvals, region_pops, split_district_only, verbose)
}

perform_merge_split_steps <- function(adj_list, counties, pop, k_param, target, lower, upper, N, num_regions, num_districts, region_ids, region_dvals, region_pops, split_district_only, num_merge_split_steps, verbose) {
    .Call(`_redist_perform_merge_split_steps`, adj_list, counties, pop, k_param, target, lower, upper, N, num_regions, num_districts, region_ids, region_dvals, region_pops, split_district_only, num_merge_split_steps, verbose)
}

swMH <- function(aList, cdvec, popvec, nsims, constraints, eprob, pct_dist_parity, beta_sequence, beta_weights, lambda = 0L, beta = 0.0, adapt_beta = "none", adjswap = 1L, exact_mh = 0L, adapt_eprob = 0L, adapt_lambda = 0L, num_hot_steps = 0L, num_annealing_steps = 0L, num_cold_steps = 0L, verbose = TRUE) {
    .Call(`_redist_swMH`, aList, cdvec, popvec, nsims, constraints, eprob, pct_dist_parity, beta_sequence, beta_weights, lambda, beta, adapt_beta, adjswap, exact_mh, adapt_eprob, adapt_lambda, num_hot_steps, num_annealing_steps, num_cold_steps, verbose)
}

split_entire_map_once_new_cut_func <- function(N, adj_list, counties, pop, target, lower, upper, split_district_only, verbose) {
    .Call(`_redist_split_entire_map_once_new_cut_func`, N, adj_list, counties, pop, target, lower, upper, split_district_only, verbose)
}

#' Creates the region level graph of a plan
#'
#' Given a plan object this returns a graph of the regions in the plan using
#' the region ids as indices
#'
#' @title Get Region-Level Graph
#'
#' @param g The graph of the entire map
#' @param plan A plan object
#'
#' @details No modifications to inputs made
#'
#' @return the log of the probability the specific value of `region_to_split` was chosen
#'
NULL

tree_pop <- function(ust, vtx, pop, pop_below, parent) {
    .Call(`_redist_tree_pop`, ust, vtx, pop, pop_below, parent)
}

var_info_vec <- function(m, ref, pop) {
    .Call(`_redist_var_info_vec`, m, ref, pop)
}

#' Computes the effective sample size from log incremental weights
#'
#' Takes a vector of log incremental weights and computes the effective sample
#' size which is the sum of the weights squared divided by the sum of squared
#' weights
#'
#'
#' @title Compute Effective Sample Size
#'
#' @param log_wgt vector of log incremental weights
#'
#' @details No modifications to inputs made
#'
#' @return sum of weights squared over sum of squared weights (sum(wgt)^2 / sum(wgt^2))
#'
NULL

#' Computes log unnormalized weights for vector of plans
#'
#' Using the procedure outlined in <PAPER HERE> this function computes the log
#' incremental weights and the unnormalized weights for a vector of plans (which
#' may or may not be the same depending on the parameters).
#'
#' @title Compute Log Unnormalized Weights
#'
#' @param pool A threadpool for multithreading
#' @param g A graph (adjacency list) passed by reference
#' @param plans_vec A vector of plans to compute the log unnormalized weights
#' of
#' @param split_district_only whether or not to compute the weights under 
#' the district only split scheme or not. If `split_district_only` is true
#' then uses optimal weights from one-district split scheme.
#' @param log_incremental_weights A vector of the log incremental weights
#' computed for the plans. The value of `log_incremental_weights[i]` is
#' the log incremental weight for `plans_vec[i]`
#' @param unnormalized_sampling_weights A vector of the unnormalized sampling
#' weights to be used with sampling the `plans_vec` in the next iteration of the
#' algorithm. Depending on the other hyperparameters this may or may not be the
#' same as `exp(log_incremental_weights)`
#' @param target Target population of a single district
#' @param pop_temper <DETAILS NEEDED>
#'
#' @details Modifications
#'    - The `log_incremental_weights` is updated to contain the incremental
#'    weights of the plans
#'    - The `unnormalized_sampling_weights` is updated to contain the unnormalized
#'    sampling weights of the plans for the next round
NULL

sample_ust <- function(l, pop, lower, upper, counties, ignore) {
    .Call(`_redist_sample_ust`, l, pop, lower, upper, counties, ignore)
}


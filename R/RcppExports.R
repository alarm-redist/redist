# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

reduce_adj <- function(adj_list, prec_map, n_keep) {
    .Call(`_gredist_reduce_adj`, adj_list, prec_map, n_keep)
}

collapse_adj <- function(graph, idxs) {
    .Call(`_gredist_collapse_adj`, graph, idxs)
}

coarsen_adjacency <- function(adj, groups) {
    .Call(`_gredist_coarsen_adjacency`, adj, groups)
}

get_plan_graph <- function(l, V, plan, n_distr) {
    .Call(`_gredist_get_plan_graph`, l, V, plan, n_distr)
}

color_graph <- function(l, plan) {
    .Call(`_gredist_color_graph`, l, plan)
}

polsbypopper <- function(from, to, area, perimeter, dm, nd) {
    .Call(`_gredist_polsbypopper`, from, to, area, perimeter, dm, nd)
}

genAlConn <- function(aList, cds) {
    .Call(`_gredist_genAlConn`, aList, cds)
}

findBoundary <- function(fullList, conList) {
    .Call(`_gredist_findBoundary`, fullList, conList)
}

contiguity <- function(adj, group) {
    .Call(`_gredist_contiguity`, adj, group)
}

cores <- function(adj, dm, k, cd_within_k) {
    .Call(`_gredist_cores`, adj, dm, k, cd_within_k)
}

update_conncomp <- function(dm, kvec, adj) {
    .Call(`_gredist_update_conncomp`, dm, kvec, adj)
}

crsg <- function(adj_list, population, area, x_center, y_center, Ndistrict, target_pop, thresh, maxiter) {
    .Call(`_gredist_crsg`, adj_list, population, area, x_center, y_center, Ndistrict, target_pop, thresh, maxiter)
}

dist_dist_diff <- function(p, i_dist, j_dist, x_center, y_center, x, y) {
    .Call(`_gredist_dist_dist_diff`, p, i_dist, j_dist, x_center, y_center, x, y)
}

#' Run Optimalgsmc with Merge Split
#'
#' Uses gsmc method with optimal weights and merge split steps to generate a sample of `M` plans in `c++` 
#' 
#' 
#' Using the procedure outlined in <PAPER HERE> this function uses Sequential
#' Monte Carlo (SMC) methods to generate a sample of `M` plans
#'
#'
#' @param N The number of districts the final plans will have
#' @param adj_list A 0-indexed adjacency list representing the undirected graph
#' which represents the underlying map the plans are to be drawn on
#' @param counties Vector of county labels of each vertex in `g`
#' @param pop A vector of the population associated with each vertex in `g`
#' @param target Ideal population of a valid district. This is what deviance is calculated
#' relative to
#' @param lower Acceptable lower bounds on a valid district's population
#' @param upper Acceptable upper bounds on a valid district's population
#' @param nsims The number of plans (samples) to draw
#' @param k_param The k parameter from the SMC algorithm, you choose among the top k_param edges
#' @param control Named list of additional parameters.
#' @param num_threads The number of threads the threadpool should use
#' @param verbosity What level of detail to print out while the algorithm is
#' running <ADD OPTIONS>
#' @export
#' @keywords internal
run_redist_gsmc <- function(N, adj_list, counties, pop, target, lower, upper, nsims, region_id_mat, region_sizes_mat, sampling_space, control, verbosity = 3L, diagnostic_mode = FALSE) {
    .Call(`_gredist_run_redist_gsmc`, N, adj_list, counties, pop, target, lower, upper, nsims, region_id_mat, region_sizes_mat, sampling_space, control, verbosity, diagnostic_mode)
}

log_st_map <- function(g, districts, counties, n_distr) {
    .Call(`_gredist_log_st_map`, g, districts, counties, n_distr)
}

n_removed <- function(g, districts, n_distr) {
    .Call(`_gredist_n_removed`, g, districts, n_distr)
}

countpartitions <- function(aList) {
    .Call(`_gredist_countpartitions`, aList)
}

calcPWDh <- function(x) {
    .Call(`_gredist_calcPWDh`, x)
}

#'
#' @returns A list with the following 
#'     - `uncut_tree`: The spanning tree drawn on the region stored as a
#'     0-indexed directed edge adjacency graph.
#'     - `num_attempts`: The number of attempts it took to draw the tree.
#' 
#' @keywords internal
draw_a_tree_on_a_region <- function(adj_list, counties, pop, ndists, num_regions, num_districts, region_id_to_draw_tree_on, lower, upper, region_ids, region_sizes, verbose) {
    .Call(`_gredist_draw_a_tree_on_a_region`, adj_list, counties, pop, ndists, num_regions, num_districts, region_id_to_draw_tree_on, lower, upper, region_ids, region_sizes, verbose)
}

#' Splits a multidistrict into two new regions within population bounds
#'
#' Splits a multidistrict into two new valid regions by drawing spanning
#' trees uniformly at random and attempting to find an edge to cut until
#' a successful cut is made.
#'
#' @title Split a multidistrict into two regions
#'
#' @inheritParams run_redist_gsmc
perform_a_valid_multidistrict_split <- function(adj_list, counties, pop, N, num_regions, num_districts, region_id_to_split, target, lower, upper, region_ids, region_sizes, split_dval_min, split_dval_max, split_district_only, verbose = FALSE, k_param = 1L) {
    .Call(`_gredist_perform_a_valid_multidistrict_split`, adj_list, counties, pop, N, num_regions, num_districts, region_id_to_split, target, lower, upper, region_ids, region_sizes, split_dval_min, split_dval_max, split_district_only, verbose, k_param)
}

perform_merge_split_steps <- function(adj_list, counties, pop, k_param, target, lower, upper, N, num_regions, num_districts, region_ids, region_sizes, region_pops, split_district_only, num_merge_split_steps, verbose) {
    .Call(`_gredist_perform_merge_split_steps`, adj_list, counties, pop, k_param, target, lower, upper, N, num_regions, num_districts, region_ids, region_sizes, region_pops, split_district_only, num_merge_split_steps, verbose)
}

group_pct_top_k <- function(m, group_pop, total_pop, k, n_distr) {
    .Call(`_gredist_group_pct_top_k`, m, group_pop, total_pop, k, n_distr)
}

proj_distr_m <- function(districts, x, draw_idx, n_distr) {
    .Call(`_gredist_proj_distr_m`, districts, x, draw_idx, n_distr)
}

colmax <- function(x) {
    .Call(`_gredist_colmax`, x)
}

colmin <- function(x) {
    .Call(`_gredist_colmin`, x)
}

prec_cooccur <- function(m, idxs, ncores = 0L) {
    .Call(`_gredist_prec_cooccur`, m, idxs, ncores)
}

group_pct <- function(m, group_pop, total_pop, n_distr) {
    .Call(`_gredist_group_pct`, m, group_pop, total_pop, n_distr)
}

pop_tally <- function(districts, pop, n_distr) {
    .Call(`_gredist_pop_tally`, districts, pop, n_distr)
}

max_dev <- function(districts, pop, n_distr) {
    .Call(`_gredist_max_dev`, districts, pop, n_distr)
}

ms_plans <- function(N, l, init, counties, pop, n_distr, target, lower, upper, rho, constraints, control, k, thin, verbosity) {
    .Call(`_gredist_ms_plans`, N, l, init, counties, pop, n_distr, target, lower, upper, rho, constraints, control, k, thin, verbosity)
}

pareto_dominated <- function(x) {
    .Call(`_gredist_pareto_dominated`, x)
}

plan_copy_testing <- function() {
    .Call(`_gredist_plan_copy_testing`)
}

new_plan_testing <- function(region_id_mat, region_id_mat2) {
    .Call(`_gredist_new_plan_testing`, region_id_mat, region_id_mat2)
}

arma_testing <- function() {
    .Call(`_gredist_arma_testing`)
}

random_cpp_testing <- function() {
    invisible(.Call(`_gredist_random_cpp_testing`))
}

closest_adj_pop <- function(adj, i_dist, g_prop) {
    .Call(`_gredist_closest_adj_pop`, adj, i_dist, g_prop)
}

rint1 <- function(n, max) {
    .Call(`_gredist_rint1`, n, max)
}

runif1 <- function(n, max) {
    .Call(`_gredist_runif1`, n, max)
}

resample_lowvar <- function(wgts) {
    .Call(`_gredist_resample_lowvar`, wgts)
}

#' Copies data from an arma Matrix into an Rcpp Matrix
#'
#' Takes an arma matrix subview and copies all the data into an RcppMatrix
#' of the same size using the Rcpp Threadpool to copy in parallel. 
#'
#'
#' @title Copies data from an arma Matrix into an Rcpp Matrix
#'
#' @param pool A threadpool for multithreading
#' @param arma_mat Subview of an arma unsigned integer matrix 
#' @param rcpp_mat A matrix of integers with the same size as the arma_mat
#'
#' @details Modifications
#'    - The `rcpp_mat` is filled in with the data om the arma matrix subview
#'
#' @noRd
#' @keywords internal
NULL

#' Reorders all the plans in the vector by order a region was split
#'
#' Takes a vector of plans and uses the vector of dummy plans to reorder
#' each of the plans by the order a region was split.
#'
#'
#' @title Reorders all the plans in the vector by order a region was split
#'
#' @param pool A threadpool for multithreading
#' @param plan_ptrs_vec A vector of pointers to plans 
#' @param dummy_plans_vec A vector of pointers to dummy plans 
#'
#' @details Modifications
#'    - Each plan in the `plans_vec` object is reordered by when the region was split
#'    - Each plan is a shallow copy of the plans in `plans_vec`
#'
#' @noRd
#' @keywords internal
NULL

plan_joint <- function(m1, m2, pop) {
    .Call(`_gredist_plan_joint`, m1, m2, pop)
}

renumber_matrix <- function(plans, renumb) {
    .Call(`_gredist_renumber_matrix`, plans, renumb)
}

solve_hungarian <- function(costMatrix) {
    .Call(`_gredist_solve_hungarian`, costMatrix)
}

rsg <- function(adj_list, population, Ndistrict, target_pop, thresh, maxiter) {
    .Call(`_gredist_rsg`, adj_list, population, Ndistrict, target_pop, thresh, maxiter)
}

k_smallest <- function(x, k = 1L) {
    .Call(`_gredist_k_smallest`, x, k)
}

k_biggest <- function(x, k = 1L) {
    .Call(`_gredist_k_biggest`, x, k)
}

smc_plans <- function(N, l, counties, pop, n_distr, target, lower, upper, rho, districts, n_drawn, n_steps, constraints, control, verbosity = 1L) {
    .Call(`_gredist_smc_plans`, N, l, counties, pop, n_distr, target, lower, upper, rho, districts, n_drawn, n_steps, constraints, control, verbosity)
}

splits <- function(dm, community, nd, max_split) {
    .Call(`_gredist_splits`, dm, community, nd, max_split)
}

dist_cty_splits <- function(dm, community, nd) {
    .Call(`_gredist_dist_cty_splits`, dm, community, nd)
}

#' Splits a multidistrict in all of the plans
#'
#' Using the procedure outlined in <PAPER HERE> this function attempts to split
#' a multidistrict in a previous steps plan until M successful splits have been made. This
#' is based on the `split_maps` function in smc.cpp
#'
#' @title Split all the maps
#'
#' @param g A graph (adjacency list) passed by reference
#' @param counties Vector of county labels of each vertex in `g`
#' @param cg County level multigraph
#' @param pop A vector of the population associated with each vertex in `g`
#' @param old_plans_vec A vector of plans from the previous step
#' @param new_plans_vec A vector which will be filled with plans that had a
#' multidistrict split to make them
#' @param parent_index_vec A vector used to track the index of the previous plan
#' sampled that was successfully split. The value of `parent_index_vec[i]` is the
#' index of the old plan from which the new plan `new_plans_vec[i]` was
#' successfully split from. In other words `new_plans_vec[i]` is equal to
#' `attempt_region_split(old_plans_vec[parent_index_vec[i]], ...)`
#' @param unnormalized_sampling_weights A vector of weights used to sample indices
#' of the `old_plans_vec`. The value of `unnormalized_sampling_weights[i]` is
#' the unnormalized probability that index i is selected
#' @param draw_tries_vec A vector used to keep track of how many plan split
#' attempts were made for index i. The value `draw_tries_vec[i]` represents how
#' many split attempts were made for the i-th new plan (including the successful
#' split). For example, `draw_tries_vec[i] = 1` means that the first split
#' attempt was successful.
#' @param parent_unsuccessful_tries_vec A vector used to keep track of how many times the
#' previous rounds plans were sampled and unsuccessfully split. The value
#' `parent_unsuccessful_tries_vec[i]` represents how many times `old_plans_vec[i]` was sampled
#' and then unsuccessfully split while creating all `M` of the new plans.
#' THIS MAY NOT BE THREAD SAFE
#' @param accept_rate The number of accepted splits over the total number of
#' attempted splits. This is equal to `sum(draw_tries_vec)/M`
#' @param n_unique_parent_indices The number of unique parent indices, ie the
#' number of previous plans that had at least one descendant amongst the new
#' plans. This is equal to `unique(parent_index_vec)`
#' @param ancestors Parameter from older `smc.cpp` code. I DON'T UNDERSTAND
#' WHAT IT IS DOING
#' @param lags Parameter from older `smc.cpp` code. I DON'T UNDERSTAND
#' WHAT IT IS DOING
#' @param lower Acceptable lower bounds on a valid district's population
#' @param upper Acceptable upper bounds on a valid district's population
#' @param target Ideal population of a valid district. This is what deviance is calculated
#' relative to
#' @param k_param The top edges to pick parameter for the region splitting
#' algorithm
#' @param split_district_only Whether or not to only allow for single district
#' splits. If set to `true` will only attempt to split off one district at a
#' time
#' @param pool A threadpool for multithreading
#' @param verbosity A parameter controlling the amount of detail printed out
#' during the algorithms running
#'
#' @details Modifications
#'    - The `new_plans_vec` is updated with all the newly split plans
#'    - The `old_plans_vec` is updated with all the newly split plans as well.
#'    Note that the reason both this and `new_plans_vec` are updated is because
#'    of the nature of the code you need both vectors and so both are passed by
#'    reference to save memory.
#'    - The `original_ancestor_vec` is updated to contain the indices of the
#'    original ancestors of the new plans
#'    - The `parent_index_vec` is updated to contain the indices of the parents of the
NULL

#'    - If two new valid regions are split then the new_region_ids is updated so the
#'    first entry is the first new region and the second entry is the second new region
#'    - The `draw_tries_vec` is updated to contain the number of tries for each
#'    of the new plans
#'    - The `parent_unsuccessful_tries_vec` is updated to contain the number of unsuccessful
#'    samples of the old plans
#'    - The `accept_rate` is updated to contain the average acceptance rate for
#'    this iteration
#'    - `n_unique_parent_indices` and `n_unique_original_ancestors` are updated
#'    with the unique number of parents and original ancestors for all the new
#'    plans respectively
#'    - `ancestors` is updated to something. THIS IS FROM ORIGINAL SMC CODE,
#'    I DO NOT KNOW WHAT IT MEANS
#'
#' @noRd
#' @keywords internal
NULL

swMH <- function(aList, cdvec, popvec, nsims, constraints, eprob, pct_dist_parity, beta_sequence, beta_weights, lambda = 0L, beta = 0.0, adapt_beta = "none", adjswap = 1L, exact_mh = 0L, adapt_eprob = 0L, adapt_lambda = 0L, num_hot_steps = 0L, num_annealing_steps = 0L, num_cold_steps = 0L, verbose = TRUE) {
    .Call(`_gredist_swMH`, aList, cdvec, popvec, nsims, constraints, eprob, pct_dist_parity, beta_sequence, beta_weights, lambda, beta, adapt_beta, adjswap, exact_mh, adapt_eprob, adapt_lambda, num_hot_steps, num_annealing_steps, num_cold_steps, verbose)
}

tree_pop <- function(ust, vtx, pop, pop_below, parent) {
    .Call(`_gredist_tree_pop`, ust, vtx, pop, pop_below, parent)
}

#' Attempt to pick one of the top k tree edges to split uniformly at random
#'
#' 
#' Attempts to pick one of the top k tree edges to split uniformly at random
#' and if successful returns information on the edge and region sizes 
#' associated with the cut. This function is based on `cut_districts` in `smc.cpp`
#' however the crucial difference is even if a successful cut is found it does not
#' update the plan or the tree.
#'
#'
#' It will only attempt to create regions where the size is between
#' min_potential_d and max_potential_d (inclusive). So the one district
#' split case is `min_potential_d=max_potential_d=1`.
#' 
#' Best edge here is defined as the smallest deviation where the deviation for
#' an edge, size is defined as abs(population - target*size)/target*size. 
#'
#' 
#' @param root The root vertex of the spanning tree
#' @param pop_below The population corresponding to cutting below each vertex. 
#' So `pop_below[v]` is the population associated with the region made by cutting
#' below the vertex `v`
#' @param tree_vertex_parents The parent of each vertex in the tree. A value of -1
#' means the vertex is the root or it is not in the tree.
#' @param k_param The number of best edges we should choose from uniformly
#' at random
#' @param min_potential_cut_size The smallest potential region size to try for a cut. 
#' @param max_potential_cut_size The largest potential region size it will try for a cut. 
#' Setting this to 1 will result in only 1 district splits. 
#' @param region_ids A vector mapping 0 indexed vertices to their region id number
#' @param region_id_to_split The id of the region in the plan object we're attempting to split
#' @param total_region_pop The total population of the region being split 
#' @param total_region_size The size of the region being split 
#' @param lower Acceptable lower bounds on a valid district's population
#' @param upper Acceptable upper bounds on a valid district's population
#' @param target Ideal population of a valid district. This is what deviance is calculated
#' relative to
#'
#' @details No modifications made
#'
#' @return <True, information on the edge cut> if two valid regions were 
#' successfully split, false otherwise
#'
#' @noRd
#' @keywords internal
NULL

var_info_vec <- function(m, ref, pop) {
    .Call(`_gredist_var_info_vec`, m, ref, pop)
}

#' Computes the effective sample size from log incremental weights
#'
#' Takes a vector of log incremental weights and computes the effective sample
#' size which is the sum of the weights squared divided by the sum of squared
#' weights
#'
#'
#' @title Compute Effective Sample Size
#'
#' @param log_wgt vector of log incremental weights
#'
#' @details No modifications to inputs made
#'
#' @return sum of weights squared over sum of squared weights (sum(wgt)^2 / sum(wgt^2))
#'
NULL

#' Returns a vector of the triple (smaller region id, bigger region id, boundary len)
#' for all valid pairs of adjacent regions in the plan. (Either all adjacent regions if
#' doing generalized region splits or just adjacent to the remainder if only doing 
#' one district splits.)
#'
#'
#' @title Get All Valid Adjacent Regions and their Boundary Length
#'
#' @param g A graph (adjacency list) passed by reference
#' @param plan A plan object
#' @param split_district_only If true only gets regions adjacent to the remainder but if 
#' false then gets all adjacent regions in the plan
#'
#' @details No modifications to inputs made
#'
#' @return A vector of integer arrays of size 3 where the values are
#' (smaller region id, bigger region id, boundary len)
#'
NULL

#'
#' Current supported options are
#'     - uniform - Every pair has equal probability
#'     - district_pair - double district pairs have weight 1000, one district is 10,
#'         and two multidistricts have 1/(1+sum of their dvals)
#'
#' @title Get Sampler over Adj Regions List
#'
#' @param plan A plan object
#' @param adj_pairs_and_boundary_lens A vector where each pair is 
#' (adj region1, adj region2, boundary length between 2 regions)
#' @param selection_type A string controlling the function to use
#' in assigning the unnormalized weight to each pair
#'
#' @details No modifications to inputs made
#'
#' @return A sampler where index i has probability proportional to the weight 
#' given to that pair 
#'
NULL

#' Computes log unnormalized weights for vector of plans
#'
#' Using the procedure outlined in <PAPER HERE> this function computes the log
#' incremental weights and the unnormalized weights for a vector of plans (which
#' may or may not be the same depending on the parameters).
#'
#' @title Compute Log Unnormalized Weights
#'
#' @param pool A threadpool for multithreading
#' @param g A graph (adjacency list) passed by reference
#' @param plans_ptr_vec A vector of plans to compute the log unnormalized weights
#' of
#' @param split_district_only whether or not to compute the weights under 
#' the district only split scheme or not. If `split_district_only` is true
#' then uses optimal weights from one-district split scheme.
#' @param log_incremental_weights A vector of the log incremental weights
#' computed for the plans. The value of `log_incremental_weights[i]` is
#' the log incremental weight for `plans_vec[i]`
#' @param unnormalized_sampling_weights A vector of the unnormalized sampling
#' weights to be used with sampling the `plans_vec` in the next iteration of the
#' algorithm. Depending on the other hyperparameters this may or may not be the
#' same as `exp(log_incremental_weights)`
#' @param target Target population of a single district
#' @param pop_temper <DETAILS NEEDED>
#'
#' @details Modifications
#'    - The `log_incremental_weights` is updated to contain the incremental
#'    weights of the plans
#'    - The `unnormalized_sampling_weights` is updated to contain the unnormalized
#'    sampling weights of the plans for the next round
NULL

sample_ust <- function(l, pop, lower, upper, counties, ignore) {
    .Call(`_gredist_sample_ust`, l, pop, lower, upper, counties, ignore)
}


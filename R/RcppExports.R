# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

reduce_adj <- function(adj_list, prec_map, n_keep) {
    .Call(`_gredist_reduce_adj`, adj_list, prec_map, n_keep)
}

collapse_adj <- function(graph, idxs) {
    .Call(`_gredist_collapse_adj`, graph, idxs)
}

coarsen_adjacency <- function(adj, groups) {
    .Call(`_gredist_coarsen_adjacency`, adj, groups)
}

get_plan_graph <- function(l, V, plan, n_distr) {
    .Call(`_gredist_get_plan_graph`, l, V, plan, n_distr)
}

color_graph <- function(l, plan) {
    .Call(`_gredist_color_graph`, l, plan)
}

polsbypopper <- function(from, to, area, perimeter, dm, nd) {
    .Call(`_gredist_polsbypopper`, from, to, area, perimeter, dm, nd)
}

genAlConn <- function(aList, cds) {
    .Call(`_gredist_genAlConn`, aList, cds)
}

findBoundary <- function(fullList, conList) {
    .Call(`_gredist_findBoundary`, fullList, conList)
}

contiguity <- function(adj, group) {
    .Call(`_gredist_contiguity`, adj, group)
}

cores <- function(adj, dm, k, cd_within_k) {
    .Call(`_gredist_cores`, adj, dm, k, cd_within_k)
}

update_conncomp <- function(dm, kvec, adj) {
    .Call(`_gredist_update_conncomp`, dm, kvec, adj)
}

crsg <- function(adj_list, population, area, x_center, y_center, Ndistrict, target_pop, thresh, maxiter) {
    .Call(`_gredist_crsg`, adj_list, population, area, x_center, y_center, Ndistrict, target_pop, thresh, maxiter)
}

dist_dist_diff <- function(p, i_dist, j_dist, x_center, y_center, x, y) {
    .Call(`_gredist_dist_dist_diff`, p, i_dist, j_dist, x_center, y_center, x, y)
}

#' Uses gsmc method with optimal weights and merge split steps to generate a sample of `M` plans in `c++`
#'
#' Using the procedure outlined in <PAPER HERE> this function uses Sequential
#' Monte Carlo (SMC) methods to generate a sample of `M` plans
#'
#' @title Run Optimalgsmc with Merge Split
#'
#' @param N The number of districts the final plans will have
#' @param adj_list A 0-indexed adjacency list representing the undirected graph
#' which represents the underlying map the plans are to be drawn on
#' @param counties Vector of county labels of each vertex in `g`
#' @param pop A vector of the population associated with each vertex in `g`
#' @param target Ideal population of a valid district. This is what deviance is calculated
#' relative to
#' @param lower Acceptable lower bounds on a valid district's population
#' @param upper Acceptable upper bounds on a valid district's population
#' @param M The number of plans (samples) to draw
#' @param k_param The k parameter from the SMC algorithm, you choose among the top k_param edges
#' @param control Named list of additional parameters.
#' @param num_threads The number of threads the threadpool should use
#' @param verbosity What level of detail to print out while the algorithm is
#' running <ADD OPTIONS>
#' @export
optimal_gsmc_with_merge_split_plans <- function(N, adj_list, counties, pop, target, lower, upper, M, region_id_mat, region_dvals_mat, control, verbosity = 3L, diagnostic_mode = FALSE) {
    .Call(`_gredist_optimal_gsmc_with_merge_split_plans`, N, adj_list, counties, pop, target, lower, upper, M, region_id_mat, region_dvals_mat, control, verbosity, diagnostic_mode)
}

log_st_map <- function(g, districts, counties, n_distr) {
    .Call(`_gredist_log_st_map`, g, districts, counties, n_distr)
}

n_removed <- function(g, districts, n_distr) {
    .Call(`_gredist_n_removed`, g, districts, n_distr)
}

countpartitions <- function(aList) {
    .Call(`_gredist_countpartitions`, aList)
}

calcPWDh <- function(x) {
    .Call(`_gredist_calcPWDh`, x)
}

#'
#' @returns A list with the following 
#'     - `uncut_tree`: The spanning tree drawn on the region stored as a
#'     0-indexed directed edge adjacency graph.
#'     - `num_attempts`: The number of attempts it took to draw the tree.
#' 
#' @keywords internal
draw_a_tree_on_a_region <- function(adj_list, counties, pop, ndists, num_regions, num_districts, region_id_to_draw_tree_on, lower, upper, region_ids, region_dvals, verbose) {
    .Call(`_gredist_draw_a_tree_on_a_region`, adj_list, counties, pop, ndists, num_regions, num_districts, region_id_to_draw_tree_on, lower, upper, region_ids, region_dvals, verbose)
}

perform_a_valid_region_split <- function(adj_list, counties, pop, N, num_regions, num_districts, region_id_to_split, target, lower, upper, region_ids, region_dvals, split_dval_min, split_dval_max, verbose = FALSE, k_param = 1L) {
    .Call(`_gredist_perform_a_valid_region_split`, adj_list, counties, pop, N, num_regions, num_districts, region_id_to_split, target, lower, upper, region_ids, region_dvals, split_dval_min, split_dval_max, verbose, k_param)
}

perform_merge_split_steps <- function(adj_list, counties, pop, k_param, target, lower, upper, N, num_regions, num_districts, region_ids, region_dvals, region_pops, split_district_only, num_merge_split_steps, verbose) {
    .Call(`_gredist_perform_merge_split_steps`, adj_list, counties, pop, k_param, target, lower, upper, N, num_regions, num_districts, region_ids, region_dvals, region_pops, split_district_only, num_merge_split_steps, verbose)
}

group_pct_top_k <- function(m, group_pop, total_pop, k, n_distr) {
    .Call(`_gredist_group_pct_top_k`, m, group_pop, total_pop, k, n_distr)
}

proj_distr_m <- function(districts, x, draw_idx, n_distr) {
    .Call(`_gredist_proj_distr_m`, districts, x, draw_idx, n_distr)
}

colmax <- function(x) {
    .Call(`_gredist_colmax`, x)
}

colmin <- function(x) {
    .Call(`_gredist_colmin`, x)
}

prec_cooccur <- function(m, idxs, ncores = 0L) {
    .Call(`_gredist_prec_cooccur`, m, idxs, ncores)
}

group_pct <- function(m, group_pop, total_pop, n_distr) {
    .Call(`_gredist_group_pct`, m, group_pop, total_pop, n_distr)
}

pop_tally <- function(districts, pop, n_distr) {
    .Call(`_gredist_pop_tally`, districts, pop, n_distr)
}

max_dev <- function(districts, pop, n_distr) {
    .Call(`_gredist_max_dev`, districts, pop, n_distr)
}

ms_plans <- function(N, l, init, counties, pop, n_distr, target, lower, upper, rho, constraints, control, k, thin, verbosity) {
    .Call(`_gredist_ms_plans`, N, l, init, counties, pop, n_distr, target, lower, upper, rho, constraints, control, k, thin, verbosity)
}

#' Uses gsmc method with optimal weights to generate a sample of `M` plans in `c++`
#'
#' Using the procedure outlined in <PAPER HERE> this function uses Sequential
#' Monte Carlo (SMC) methods to generate a sample of `M` plans
#'
#' @title Run Optimalgsmc
#'
#' @param N The number of districts the final plans will have
#' @param adj_list A 0-indexed adjacency list representing the undirected graph
#' which represents the underlying map the plans are to be drawn on
#' @param counties Vector of county labels of each vertex in `g`
#' @param pop A vector of the population associated with each vertex in `g`
#' @param target Ideal population of a valid district. This is what deviance is calculated
#' relative to
#' @param lower Acceptable lower bounds on a valid district's population
#' @param upper Acceptable upper bounds on a valid district's population
#' @param M The number of plans (samples) to draw
#' @param k_param The k parameter from the SMC algorithm, you choose among the top k_param edges
#' @param control Named list of additional parameters.
#' @param num_threads The number of threads the threadpool should use
#' @param verbosity What level of detail to print out while the algorithm is
#' running <ADD OPTIONS>
#' @export
optimal_gsmc_plans <- function(N, adj_list, counties, pop, target, lower, upper, M, control, num_threads = -1L, verbosity = 3L, diagnostic_mode = FALSE) {
    .Call(`_gredist_optimal_gsmc_plans`, N, adj_list, counties, pop, target, lower, upper, M, control, num_threads, verbosity, diagnostic_mode)
}

pareto_dominated <- function(x) {
    .Call(`_gredist_pareto_dominated`, x)
}

new_plan_testing <- function(region_id_mat, region_id_mat2) {
    .Call(`_gredist_new_plan_testing`, region_id_mat, region_id_mat2)
}

arma_testing <- function() {
    .Call(`_gredist_arma_testing`)
}

random_cpp_testing <- function() {
    invisible(.Call(`_gredist_random_cpp_testing`))
}

closest_adj_pop <- function(adj, i_dist, g_prop) {
    .Call(`_gredist_closest_adj_pop`, adj, i_dist, g_prop)
}

rint1 <- function(n, max) {
    .Call(`_gredist_rint1`, n, max)
}

runif1 <- function(n, max) {
    .Call(`_gredist_runif1`, n, max)
}

resample_lowvar <- function(wgts) {
    .Call(`_gredist_resample_lowvar`, wgts)
}

plan_joint <- function(m1, m2, pop) {
    .Call(`_gredist_plan_joint`, m1, m2, pop)
}

renumber_matrix <- function(plans, renumb) {
    .Call(`_gredist_renumber_matrix`, plans, renumb)
}

solve_hungarian <- function(costMatrix) {
    .Call(`_gredist_solve_hungarian`, costMatrix)
}

rsg <- function(adj_list, population, Ndistrict, target_pop, thresh, maxiter) {
    .Call(`_gredist_rsg`, adj_list, population, Ndistrict, target_pop, thresh, maxiter)
}

k_smallest <- function(x, k = 1L) {
    .Call(`_gredist_k_smallest`, x, k)
}

k_biggest <- function(x, k = 1L) {
    .Call(`_gredist_k_biggest`, x, k)
}

smc_plans <- function(N, l, counties, pop, n_distr, target, lower, upper, rho, districts, n_drawn, n_steps, constraints, control, verbosity = 1L) {
    .Call(`_gredist_smc_plans`, N, l, counties, pop, n_distr, target, lower, upper, rho, districts, n_drawn, n_steps, constraints, control, verbosity)
}

#' Copies data from an arma Matrix into an Rcpp Matrix
#'
#' Takes an arma matrix subview and copies all the data into an RcppMatrix
#' of the same size using the Rcpp Threadpool to copy in parallel. 
#'
#'
#' @title Copies data from an arma Matrix into an Rcpp Matrix
#'
#' @param pool A threadpool for multithreading
#' @param arma_mat Subview of an arma unsigned integer matrix 
#' @param rcpp_mat A matrix of integers with the same size as the arma_mat
#'
#' @details Modifications
#'    - The `rcpp_mat` is filled in with the data om the arma matrix subview
#'
#' @noRd
#' @keywords internal
NULL

#' Reorders all the plans in the vector by order a region was split
#'
#' Takes a vector of plans and uses the vector of dummy plans to reorder
#' each of the plans by the order a region was split.
#'
#'
#' @title Reorders all the plans in the vector by order a region was split
#'
#' @param pool A threadpool for multithreading
#' @param plans_vec A vector of plans
#' @param dummy_plans_vec A vector of dummy plans 
#'
#' @details Modifications
#'    - Each plan in the `plans_vec` object is reordered by when the region was split
#'    - Each plan is a shallow copy of the plans in `plans_vec`
#'
#' @noRd
#' @keywords internal
NULL

splits <- function(dm, community, nd, max_split) {
    .Call(`_gredist_splits`, dm, community, nd, max_split)
}

dist_cty_splits <- function(dm, community, nd) {
    .Call(`_gredist_dist_cty_splits`, dm, community, nd)
}

#' Attempts to cut one region into two from a spanning tree and if successful
#' cuts the tree object and returns information on what the two new regions 
#' would be. Does not actually update the plan vertex list.
#'
#' Takes a spanning tree `ust` drawn on a specific region and attempts to cut
#' it to produce two new regions using the generalized splitting procedure
#' outlined <PAPER HERE>. This function is based on `cut_districts` in `smc.cpp`
#' however the crucial difference is even if a cut is successful it does not
#' update the plan. Instead it just returns the information on the two new
#' regions if successful and the cut tree.
#'
#' It will only attempt to create regions where the size is between
#' min_potential_d and max_potential_d (inclusive). So the one district
#' split case is `min_potential_d=max_potential_d=1`.
#'
#' By convention the first new region (`new_region1`) will always be the region
#' with the smaller d-value (although they can be equal).
#'
#' @title Attempt to Find a Valid Spanning Tree Edge to Cut into Two New Regions 
#'
#' @param ust A directed spanning tree passed by reference
#' @param root The root vertex of the spanning tree
#' @param k_param The k parameter from the SMC algorithm, you choose among the top k_param edges
#' @param min_potential_d The smallest potential d value it will try for a cut. 
#' @param max_potential_d The largest potential d value it will try for a cut. Setting this to 
#' 1 will result in only 1 district splits. 
#' @param pop A vector of the population associated with each vertex in `g`
#' @param region_ids A vector mapping 0 indexed vertices to their region id number
#' @param region_id_to_split The id of the region in the plan object we're attempting to split
#' @param total_region_pop The total population of the region being split 
#' @param total_region_dval The dval of the region being split 
#' @param lower Acceptable lower bounds on a valid district's population
#' @param upper Acceptable upper bounds on a valid district's population
#' @param target Ideal population of a valid district. This is what deviance is calculated
#' relative to
#' @param new_region1_tree_root The index of the root of tree associated with
#' the first new region (if the tree cut was successful)
#' @param new_region1_dval The d-value of the first new region (if the tree cut
#'  was successful)
#' @param new_region1_pop The population of the first new region (if the tree cut
#' was successful)
#' @param new_region2_tree_root The index of the root of tree associated with
#' the second new region (if the tree cut was successful)
#' @param new_region2_dval The d-value of the second new region (if the tree cut
#'  was successful)
#' @param new_region2_pop The population of the second new region (if the tree cut
#' was successful)
#'
#' @details Modifications
#'    - If two new valid regions are split then the tree `ust` is cut into two
#'    distjoint pieces
#'    - If two new valid regions are split then the 6 `new_region` inputs are all
#'    updated by reference with the values associated with the new regions
#'
#' @return True if two valid regions were successfully split, false otherwise
#'
#' @noRd
#' @keywords internal
NULL

#' Attempts to split a multi-district within a plan into two new regions with
#' valid population bounds (has option for one district splits only)
#'
#' Given a plan this attempts to split a multi-district in it into two new
#' regions where both regions have valid population bounds. (If
#' `split_district_only` is true it will only attempt to split off a district
#' and a remainder). It does this by drawing a spanning tree uniformly at random
#' then calling `get_edge_to_cut` on  that. If the a valid cut is found it
#' then calls `update_plan_from_cut` to update the plan accordingly. If not
#' successful returns false and does nothing.
#'
#' This is based on the `split_map` function in `smc.cpp`
#'
#'
#' @title Attempt Generalized Region split of a multi-district within a plan
#'
#' @param g A graph (adjacency list) passed by reference
#' @param ust A directed tree object (this will be cleared in the function so
#' whatever it was before doesn't matter)
#' @param counties Vector of county labels of each vertex in `g`
#' @param cg multigraph object (not sure why this is needed)
#' @param plan A plan object
#' @param region_id_to_split The label of the region in the plan object we're attempting to split
#' @param new_region_id The id of the larger of the two new split reasons if successful
#' @param lower Acceptable lower bounds on a valid district's population
#' @param upper Acceptable upper bounds on a valid district's population
#' @param target Ideal population of a valid district. This is what deviance is calculated
#' relative to
#' Target population (probably Total population of map/Num districts)
#' @param k_param The k parameter from the SMC algorithm, you choose among the top k_param edges
#' @param split_district_only Whether or not to only allow for one district
#' split. If `true` then only splits off districts.
#'
#' @details Modifications
#'    - If two new valid regions are split then the plan object is updated accordingly
#'    - If two new valid regions are split then the new_region_ids is updated so the
#'    first entry is the first new region and the second entry is the second new region
#'
#' @return True if two valid regions were split off false otherwise
#'
#' @noRd
#' @keywords internal
NULL

#' Creates new regions and updates the `Plan` object using a cut tree
#'
#' Takes a cut spanning tree `ust` and variables on the two new regions
#' induced by the cuts and creates space/updates the information on those
#' two new regions in the `plan` object. This function increases the number
#' of regions aspect by 1 and updates the region level information and all
#' other variables changed by adding a new region. 
#'
#' It also sets `plan.remainder_region` equal to `new_region2_id` if 
#' split_district_only is true. 
#'
#'
#' @title Create and update new plan regions from cut tree
#'
#' @param ust A cut (ie has two partition pieces) directed spanning tree
#' passed by reference
#' @param plan A plan object
#' @param split_district_only Whether or not this was split according to a 
#' one district split scheme (as in does the remainder need to be updated)
#' @param old_split_region_id The id of the region that was split into the two
#' new ones. Region1 will be set to this id
#' @param new_region_id The id that region2 will be set 
#' @param new_region1_tree_root The vertex of the root of one piece of the cut
#' tree. This always corresponds to the region with the smaller dval (allowing
#' for the possiblity the dvals are equal).
#' @param new_region1_dval The dval associated with the new region 1
#' @param new_region1_pop The population associated with the new region 1
#' @param new_region2_tree_root The vertex of the root of other piece of the cut
#' tree. This always corresponds to the region with the bigger dval (allowing
#' for the possiblity the dvals are equal).
#' @param new_region2_dval The dval associated with the new region 2
#' @param new_region2_pop The population associated with the new region 2
#' @param new_region1_id The id the new region 1 was assigned in the plan
#' @param new_region2_id The id the new region 2 was assigned in the plan
#'
#' @details Modifications
#'    - `plan` is updated in place with the two new regions
#'    - `new_region1_id` is set to the id new region1 was assigned
#'    which is just the `old_split_region_id`
#'    - `new_region2_id` is set to the id new region2 was assigned 
#'    which is just `plan.num_regions-1`
#'
#' @noRd
#' @keywords internal
NULL

#' Splits a multidistrict in all of the plans
#'
#' Using the procedure outlined in <PAPER HERE> this function attempts to split
#' a multidistrict in a previous steps plan until M successful splits have been made. This
#' is based on the `split_maps` function in smc.cpp
#'
#' @title Split all the maps
#'
#' @param g A graph (adjacency list) passed by reference
#' @param counties Vector of county labels of each vertex in `g`
#' @param cg County level multigraph
#' @param pop A vector of the population associated with each vertex in `g`
#' @param old_plans_vec A vector of plans from the previous step
#' @param new_plans_vec A vector which will be filled with plans that had a
#' multidistrict split to make them
#' @param parent_index_vec A vector used to track the index of the previous plan
#' sampled that was successfully split. The value of `parent_index_vec[i]` is the
#' index of the old plan from which the new plan `new_plans_vec[i]` was
#' successfully split from. In other words `new_plans_vec[i]` is equal to
#' `attempt_region_split(old_plans_vec[parent_index_vec[i]], ...)`
#' @param unnormalized_sampling_weights A vector of weights used to sample indices
#' of the `old_plans_vec`. The value of `unnormalized_sampling_weights[i]` is
#' the unnormalized probability that index i is selected
#' @param draw_tries_vec A vector used to keep track of how many plan split
#' attempts were made for index i. The value `draw_tries_vec[i]` represents how
#' many split attempts were made for the i-th new plan (including the successful
#' split). For example, `draw_tries_vec[i] = 1` means that the first split
#' attempt was successful.
#' @param parent_unsuccessful_tries_vec A vector used to keep track of how many times the
#' previous rounds plans were sampled and unsuccessfully split. The value
#' `parent_unsuccessful_tries_vec[i]` represents how many times `old_plans_vec[i]` was sampled
#' and then unsuccessfully split while creating all `M` of the new plans.
#' THIS MAY NOT BE THREAD SAFE
#' @param accept_rate The number of accepted splits over the total number of
#' attempted splits. This is equal to `sum(draw_tries_vec)/M`
#' @param n_unique_parent_indices The number of unique parent indices, ie the
#' number of previous plans that had at least one descendant amongst the new
#' plans. This is equal to `unique(parent_index_vec)`
#' @param ancestors Parameter from older `smc.cpp` code. I DON'T UNDERSTAND
#' WHAT IT IS DOING
#' @param lags Parameter from older `smc.cpp` code. I DON'T UNDERSTAND
#' WHAT IT IS DOING
#' @param lower Acceptable lower bounds on a valid district's population
#' @param upper Acceptable upper bounds on a valid district's population
#' @param target Ideal population of a valid district. This is what deviance is calculated
#' relative to
#' @param k_param The top edges to pick parameter for the region splitting
#' algorithm
#' @param split_district_only Whether or not to only allow for single district
#' splits. If set to `true` will only attempt to split off one district at a
#' time
#' @param pool A threadpool for multithreading
#' @param verbosity A parameter controlling the amount of detail printed out
#' during the algorithms running
#'
#' @details Modifications
#'    - The `new_plans_vec` is updated with all the newly split plans
#'    - The `old_plans_vec` is updated with all the newly split plans as well.
#'    Note that the reason both this and `new_plans_vec` are updated is because
#'    of the nature of the code you need both vectors and so both are passed by
#'    reference to save memory.
#'    - The `original_ancestor_vec` is updated to contain the indices of the
#'    original ancestors of the new plans
#'    - The `parent_index_vec` is updated to contain the indices of the parents of the
NULL

#'    - If two new valid regions are split then the new_region_ids is updated so the
#'    first entry is the first new region and the second entry is the second new region
#'    - The `draw_tries_vec` is updated to contain the number of tries for each
#'    of the new plans
#'    - The `parent_unsuccessful_tries_vec` is updated to contain the number of unsuccessful
#'    samples of the old plans
#'    - The `accept_rate` is updated to contain the average acceptance rate for
#'    this iteration
#'    - `n_unique_parent_indices` and `n_unique_original_ancestors` are updated
#'    with the unique number of parents and original ancestors for all the new
#'    plans respectively
#'    - `ancestors` is updated to something. THIS IS FROM ORIGINAL SMC CODE,
#'    I DO NOT KNOW WHAT IT MEANS
#'
#' @noRd
#' @keywords internal
NULL

swMH <- function(aList, cdvec, popvec, nsims, constraints, eprob, pct_dist_parity, beta_sequence, beta_weights, lambda = 0L, beta = 0.0, adapt_beta = "none", adjswap = 1L, exact_mh = 0L, adapt_eprob = 0L, adapt_lambda = 0L, num_hot_steps = 0L, num_annealing_steps = 0L, num_cold_steps = 0L, verbose = TRUE) {
    .Call(`_gredist_swMH`, aList, cdvec, popvec, nsims, constraints, eprob, pct_dist_parity, beta_sequence, beta_weights, lambda, beta, adapt_beta, adjswap, exact_mh, adapt_eprob, adapt_lambda, num_hot_steps, num_annealing_steps, num_cold_steps, verbose)
}

split_entire_map_once_new_cut_func <- function(N, adj_list, counties, pop, target, lower, upper, split_district_only, verbose) {
    .Call(`_gredist_split_entire_map_once_new_cut_func`, N, adj_list, counties, pop, target, lower, upper, split_district_only, verbose)
}

#' Creates the region level graph of a plan
#'
#' Given a plan object this returns a graph of the regions in the plan using
#' the region ids as indices
#'
#' @title Get Region-Level Graph
#'
#' @param g The graph of the entire map
#' @param plan A plan object
#'
#' @details No modifications to inputs made
#'
#' @return the log of the probability the specific value of `region_to_split` was chosen
#'
NULL

tree_pop <- function(ust, vtx, pop, pop_below, parent) {
    .Call(`_gredist_tree_pop`, ust, vtx, pop, pop_below, parent)
}

var_info_vec <- function(m, ref, pop) {
    .Call(`_gredist_var_info_vec`, m, ref, pop)
}

#' Computes the effective sample size from log incremental weights
#'
#' Takes a vector of log incremental weights and computes the effective sample
#' size which is the sum of the weights squared divided by the sum of squared
#' weights
#'
#'
#' @title Compute Effective Sample Size
#'
#' @param log_wgt vector of log incremental weights
#'
#' @details No modifications to inputs made
#'
#' @return sum of weights squared over sum of squared weights (sum(wgt)^2 / sum(wgt^2))
#'
NULL

#' Returns a vector of the triple (smaller region id, bigger region id, boundary len)
#' for all valid pairs of adjacent regions in the plan. (Either all adjacent regions if
#' doing generalized region splits or just adjacent to the remainder if only doing 
#' one district splits.)
#'
#'
#' @title Get All Valid Adjacent Regions and their Boundary Length
#'
#' @param g A graph (adjacency list) passed by reference
#' @param plan A plan object
#' @param split_district_only If true only gets regions adjacent to the remainder but if 
#' false then gets all adjacent regions in the plan
#'
#' @details No modifications to inputs made
#'
#' @return A vector of integer arrays of size 3 where the values are
#' (smaller region id, bigger region id, boundary len)
#'
NULL

#'
#' Current supported options are
#'     - uniform - Every pair has equal probability
#'     - district_pair - double district pairs have weight 1000, one district is 10,
#'         and two multidistricts have 1/(1+sum of their dvals)
#'
#' @title Get Sampler over Adj Regions List
#'
#' @param plan A plan object
#' @param adj_pairs_and_boundary_lens A vector where each pair is 
#' (adj region1, adj region2, boundary length between 2 regions)
#' @param selection_type A string controlling the function to use
#' in assigning the unnormalized weight to each pair
#'
#' @details No modifications to inputs made
#'
#' @return A sampler where index i has probability proportional to the weight 
#' given to that pair 
#'
NULL

#' Computes log unnormalized weights for vector of plans
#'
#' Using the procedure outlined in <PAPER HERE> this function computes the log
#' incremental weights and the unnormalized weights for a vector of plans (which
#' may or may not be the same depending on the parameters).
#'
#' @title Compute Log Unnormalized Weights
#'
#' @param pool A threadpool for multithreading
#' @param g A graph (adjacency list) passed by reference
#' @param plans_vec A vector of plans to compute the log unnormalized weights
#' of
#' @param split_district_only whether or not to compute the weights under 
#' the district only split scheme or not. If `split_district_only` is true
#' then uses optimal weights from one-district split scheme.
#' @param log_incremental_weights A vector of the log incremental weights
#' computed for the plans. The value of `log_incremental_weights[i]` is
#' the log incremental weight for `plans_vec[i]`
#' @param unnormalized_sampling_weights A vector of the unnormalized sampling
#' weights to be used with sampling the `plans_vec` in the next iteration of the
#' algorithm. Depending on the other hyperparameters this may or may not be the
#' same as `exp(log_incremental_weights)`
#' @param target Target population of a single district
#' @param pop_temper <DETAILS NEEDED>
#'
#' @details Modifications
#'    - The `log_incremental_weights` is updated to contain the incremental
#'    weights of the plans
#'    - The `unnormalized_sampling_weights` is updated to contain the unnormalized
#'    sampling weights of the plans for the next round
NULL

sample_ust <- function(l, pop, lower, upper, counties, ignore) {
    .Call(`_gredist_sample_ust`, l, pop, lower, upper, counties, ignore)
}


# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

test_tree_prob_stuff <- function(map_adj_list, counties, pop, ndists, num_regions, target, lower, upper, min_potential_cut_size, max_potential_cut_size, region_ids, region_sizes, forest_adj_list, split_district_only, verbose) {
    .Call(`_gredist_test_tree_prob_stuff`, map_adj_list, counties, pop, ndists, num_regions, target, lower, upper, min_potential_cut_size, max_potential_cut_size, region_ids, region_sizes, forest_adj_list, split_district_only, verbose)
}

reduce_adj <- function(adj_list, prec_map, n_keep) {
    .Call(`_gredist_reduce_adj`, adj_list, prec_map, n_keep)
}

collapse_adj <- function(graph, idxs) {
    .Call(`_gredist_collapse_adj`, graph, idxs)
}

coarsen_adjacency <- function(adj, groups) {
    .Call(`_gredist_coarsen_adjacency`, adj, groups)
}

get_plan_graph <- function(l, V, plan, n_distr) {
    .Call(`_gredist_get_plan_graph`, l, V, plan, n_distr)
}

color_graph <- function(l, plan) {
    .Call(`_gredist_color_graph`, l, plan)
}

polsbypopper <- function(from, to, area, perimeter, dm, nd) {
    .Call(`_gredist_polsbypopper`, from, to, area, perimeter, dm, nd)
}

genAlConn <- function(aList, cds) {
    .Call(`_gredist_genAlConn`, aList, cds)
}

findBoundary <- function(fullList, conList) {
    .Call(`_gredist_findBoundary`, fullList, conList)
}

contiguity <- function(adj, group) {
    .Call(`_gredist_contiguity`, adj, group)
}

cores <- function(adj, dm, k, cd_within_k) {
    .Call(`_gredist_cores`, adj, dm, k, cd_within_k)
}

update_conncomp <- function(dm, kvec, adj) {
    .Call(`_gredist_update_conncomp`, dm, kvec, adj)
}

crsg <- function(adj_list, population, area, x_center, y_center, Ndistrict, target_pop, thresh, maxiter) {
    .Call(`_gredist_crsg`, adj_list, population, area, x_center, y_center, Ndistrict, target_pop, thresh, maxiter)
}

dist_dist_diff <- function(p, i_dist, j_dist, x_center, y_center, x, y) {
    .Call(`_gredist_dist_dist_diff`, p, i_dist, j_dist, x_center, y_center, x, y)
}

#' Run Optimalgsmc with Merge Split
#'
#' Uses gsmc method with optimal weights and merge split steps to generate a sample of `M` plans in `c++` 
#' 
#' 
#' Using the procedure outlined in <PAPER HERE> this function uses Sequential
#' Monte Carlo (SMC) methods to generate a sample of `M` plans
#'
#'
#' @param ndists The number of districts the final plans will have
#' @param adj_list A 0-indexed adjacency list representing the undirected graph
#' which represents the underlying map the plans are to be drawn on
#' @param counties Vector of county labels of each vertex in `g`
#' @param pop A vector of the population associated with each vertex in `g`
#' @param target Ideal population of a valid district. This is what deviance is calculated
#' relative to
#' @param lower Acceptable lower bounds on a valid district's population
#' @param upper Acceptable upper bounds on a valid district's population
#' @param nsims The number of plans (samples) to draw
#' @param k_param The k parameter from the SMC algorithm, you choose among the top k_param edges
#' @param control Named list of additional parameters.
#' @param num_threads The number of threads the threadpool should use
#' @param verbosity What level of detail to print out while the algorithm is
#' running <ADD OPTIONS>
#' @export
#' @keywords internal
run_redist_gsmc <- function(ndists, adj_list, counties, pop, step_types, target, lower, upper, region_id_mat, region_sizes_mat, sampling_space, control, constraints, verbosity = 3L, diagnostic_mode = FALSE) {
    .Call(`_gredist_run_redist_gsmc`, ndists, adj_list, counties, pop, step_types, target, lower, upper, region_id_mat, region_sizes_mat, sampling_space, control, constraints, verbosity, diagnostic_mode)
}

log_st_map <- function(g, districts, counties, n_distr) {
    .Call(`_gredist_log_st_map`, g, districts, counties, n_distr)
}

n_removed <- function(g, districts, n_distr) {
    .Call(`_gredist_n_removed`, g, districts, n_distr)
}

countpartitions <- function(aList) {
    .Call(`_gredist_countpartitions`, aList)
}

calcPWDh <- function(x) {
    .Call(`_gredist_calcPWDh`, x)
}

#'
#' @returns A list with the following 
#'     - `uncut_tree`: The spanning tree drawn on the region stored as a
#'     0-indexed directed edge adjacency graph.
#'     - `num_attempts`: The number of attempts it took to draw the tree.
#' 
#' @keywords internal
draw_a_tree_on_a_region <- function(adj_list, counties, pop, ndists, num_regions, num_districts, region_id_to_draw_tree_on, lower, upper, region_ids, region_sizes, verbose) {
    .Call(`_gredist_draw_a_tree_on_a_region`, adj_list, counties, pop, ndists, num_regions, num_districts, region_id_to_draw_tree_on, lower, upper, region_ids, region_sizes, verbose)
}

#' Splits a multidistrict into two new regions within population bounds
#'
#' Splits a multidistrict into two new valid regions by drawing spanning
#' trees uniformly at random and attempting to find an edge to cut until
#' a successful cut is made.
#'
#' @title Split a multidistrict into two regions
#'
#' @inheritParams run_redist_gsmc
perform_a_valid_multidistrict_split <- function(adj_list, counties, pop, ndists, num_regions, num_districts, region_id_to_split, target, lower, upper, region_ids, region_sizes, split_dval_min, split_dval_max, split_district_only, verbose = FALSE, k_param = 1L) {
    .Call(`_gredist_perform_a_valid_multidistrict_split`, adj_list, counties, pop, ndists, num_regions, num_districts, region_id_to_split, target, lower, upper, region_ids, region_sizes, split_dval_min, split_dval_max, split_district_only, verbose, k_param)
}

perform_merge_split_steps <- function(adj_list, counties, pop, k_param, target, lower, upper, ndists, num_regions, num_districts, region_ids, region_sizes, region_pops, split_district_only, num_merge_split_steps, verbose) {
    .Call(`_gredist_perform_merge_split_steps`, adj_list, counties, pop, k_param, target, lower, upper, ndists, num_regions, num_districts, region_ids, region_sizes, region_pops, split_district_only, num_merge_split_steps, verbose)
}

compute_a_log_optimal_weight <- function(adj_list, counties, pop, control, ndists, num_regions, lower, target, upper, region_ids, region_sizes) {
    .Call(`_gredist_compute_a_log_optimal_weight`, adj_list, counties, pop, control, ndists, num_regions, lower, target, upper, region_ids, region_sizes)
}

compute_log_unnormalized_plan_target_density <- function(adj_list, counties, pop, constraints, pop_temper, rho, ndists, num_regions, lower, target, upper, region_ids, region_sizes, num_threads) {
    .Call(`_gredist_compute_log_unnormalized_plan_target_density`, adj_list, counties, pop, constraints, pop_temper, rho, ndists, num_regions, lower, target, upper, region_ids, region_sizes, num_threads)
}

group_pct_top_k <- function(m, group_pop, total_pop, k, n_distr) {
    .Call(`_gredist_group_pct_top_k`, m, group_pop, total_pop, k, n_distr)
}

proj_distr_m <- function(districts, x, draw_idx, n_distr) {
    .Call(`_gredist_proj_distr_m`, districts, x, draw_idx, n_distr)
}

colmax <- function(x) {
    .Call(`_gredist_colmax`, x)
}

colmin <- function(x) {
    .Call(`_gredist_colmin`, x)
}

prec_cooccur <- function(m, idxs, ncores = 0L) {
    .Call(`_gredist_prec_cooccur`, m, idxs, ncores)
}

group_pct <- function(m, group_pop, total_pop, n_distr) {
    .Call(`_gredist_group_pct`, m, group_pop, total_pop, n_distr)
}

pop_tally <- function(districts, pop, n_distr) {
    .Call(`_gredist_pop_tally`, districts, pop, n_distr)
}

max_dev <- function(districts, pop, n_distr) {
    .Call(`_gredist_max_dev`, districts, pop, n_distr)
}

ms_plans <- function(nsims, warmup, l, init, counties, pop, n_distr, target, lower, upper, rho, constraints, control, k, thin, verbosity) {
    .Call(`_gredist_ms_plans`, nsims, warmup, l, init, counties, pop, n_distr, target, lower, upper, rho, constraints, control, k, thin, verbosity)
}

pareto_dominated <- function(x) {
    .Call(`_gredist_pareto_dominated`, x)
}

plan_copy_testing <- function() {
    .Call(`_gredist_plan_copy_testing`)
}

arma_testing <- function() {
    .Call(`_gredist_arma_testing`)
}

rand_int_gen_testing <- function(ndraws, max_val) {
    invisible(.Call(`_gredist_rand_int_gen_testing`, ndraws, max_val))
}

random_cpp_testing <- function() {
    .Call(`_gredist_random_cpp_testing`)
}

random_rcpp_list_cast_testing <- function(control) {
    .Call(`_gredist_random_rcpp_list_cast_testing`, control)
}

comb <- function(N, K) {
    invisible(.Call(`_gredist_comb`, N, K))
}

closest_adj_pop <- function(adj, i_dist, g_prop) {
    .Call(`_gredist_closest_adj_pop`, adj, i_dist, g_prop)
}

rint1 <- function(n, max) {
    .Call(`_gredist_rint1`, n, max)
}

runif1 <- function(n, max) {
    .Call(`_gredist_runif1`, n, max)
}

resample_lowvar <- function(wgts) {
    .Call(`_gredist_resample_lowvar`, wgts)
}

#' Copies data from an arma Matrix into an Rcpp Matrix
#'
#' Takes an arma matrix subview and copies all the data into an RcppMatrix
#' of the same size using the Rcpp Threadpool to copy in parallel. 
#'
#'
#' @title Copies data from an arma Matrix into an Rcpp Matrix
#'
#' @param pool A threadpool for multithreading
#' @param arma_mat Subview of an arma unsigned integer matrix 
#' @param rcpp_mat A matrix of integers with the same size as the arma_mat
#'
#' @details Modifications
#'    - The `rcpp_mat` is filled in with the data om the arma matrix subview
#'
#' @noRd
#' @keywords internal
NULL

#' Reorders all the plans in the vector by order a region was split
#'
#' Takes a vector of plans and uses the vector of dummy plans to reorder
#' each of the plans by the order a region was split.
#'
#'
#' @title Reorders all the plans in the vector by order a region was split
#'
#' @param pool A threadpool for multithreading
#' @param plan_ptrs_vec A vector of pointers to plans 
#' @param dummy_plans_vec A vector of pointers to dummy plans 
#'
#' @details Modifications
#'    - Each plan in the `plans_vec` object is reordered by when the region was split
#'    - Each plan is a shallow copy of the plans in `plans_vec`
#'
#' @noRd
#' @keywords internal
NULL

plan_joint <- function(m1, m2, pop) {
    .Call(`_gredist_plan_joint`, m1, m2, pop)
}

renumber_matrix <- function(plans, renumb) {
    .Call(`_gredist_renumber_matrix`, plans, renumb)
}

solve_hungarian <- function(costMatrix) {
    .Call(`_gredist_solve_hungarian`, costMatrix)
}

rsg <- function(adj_list, population, Ndistrict, target_pop, thresh, maxiter) {
    .Call(`_gredist_rsg`, adj_list, population, Ndistrict, target_pop, thresh, maxiter)
}

k_smallest <- function(x, k = 1L) {
    .Call(`_gredist_k_smallest`, x, k)
}

k_biggest <- function(x, k = 1L) {
    .Call(`_gredist_k_biggest`, x, k)
}

smc_plans <- function(N, l, counties, pop, n_distr, target, lower, upper, rho, districts, n_drawn, n_steps, constraints, control, verbosity = 1L) {
    .Call(`_gredist_smc_plans`, N, l, counties, pop, n_distr, target, lower, upper, rho, districts, n_drawn, n_steps, constraints, control, verbosity)
}

splits <- function(dm, community, nd, max_split) {
    .Call(`_gredist_splits`, dm, community, nd, max_split)
}

dist_cty_splits <- function(dm, community, nd) {
    .Call(`_gredist_dist_cty_splits`, dm, community, nd)
}

swMH <- function(aList, cdvec, popvec, nsims, constraints, eprob, pct_dist_parity, beta_sequence, beta_weights, lambda = 0L, beta = 0.0, adapt_beta = "none", adjswap = 1L, exact_mh = 0L, adapt_eprob = 0L, adapt_lambda = 0L, num_hot_steps = 0L, num_annealing_steps = 0L, num_cold_steps = 0L, verbose = TRUE) {
    .Call(`_gredist_swMH`, aList, cdvec, popvec, nsims, constraints, eprob, pct_dist_parity, beta_sequence, beta_weights, lambda, beta, adapt_beta, adjswap, exact_mh, adapt_eprob, adapt_lambda, num_hot_steps, num_annealing_steps, num_cold_steps, verbose)
}

tree_pop <- function(ust, vtx, pop, pop_below, parent) {
    .Call(`_gredist_tree_pop`, ust, vtx, pop, pop_below, parent)
}

var_info_vec <- function(m, ref, pop) {
    .Call(`_gredist_var_info_vec`, m, ref, pop)
}

#' Computes the effective sample size from log incremental weights
#'
#' Takes a vector of log incremental weights and computes the effective sample
#' size which is the sum of the weights squared divided by the sum of squared
#' weights
#'
#'
#' @title Compute Effective Sample Size
#'
#' @param log_wgt vector of log incremental weights
#'
#' @details No modifications to inputs made
#'
#' @return sum of weights squared over sum of squared weights (sum(wgt)^2 / sum(wgt^2))
#'
NULL

#' Returns a vector of the triple (smaller region id, bigger region id, boundary len)
#' for all valid pairs of adjacent regions in the plan. (Either all adjacent regions if
#' doing generalized region splits or just adjacent to the remainder if only doing 
#' one district splits.)
#'
#'
#' @title Get All Valid Adjacent Regions and their Boundary Length
#'
#' @param g A graph (adjacency list) passed by reference
#' @param plan A plan object
#' @param split_district_only If true only gets regions adjacent to the remainder but if 
#' false then gets all adjacent regions in the plan
#'
#' @details No modifications to inputs made
#'
#' @return A vector of integer arrays of size 3 where the values are
#' (smaller region id, bigger region id, boundary len)
#'
NULL

#'
#' Current supported options are
#'     - uniform - Every pair has equal probability
#'     - district_pair - double district pairs have weight 1000, one district is 10,
#'         and two multidistricts have 1/(1+sum of their dvals)
#'
#' @title Get Sampler over Adj Regions List
#'
#' @param plan A plan object
#' @param adj_pairs_and_boundary_lens A vector where each pair is 
#' (adj region1, adj region2, boundary length between 2 regions)
#' @param selection_type A string controlling the function to use
#' in assigning the unnormalized weight to each pair
#'
#' @details No modifications to inputs made
#'
#' @return A sampler where index i has probability proportional to the weight 
#' given to that pair 
#'
NULL

sample_ust <- function(l, pop, lower, upper, counties, ignore) {
    .Call(`_gredist_sample_ust`, l, pop, lower, upper, counties, ignore)
}


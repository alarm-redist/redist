% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/redist_optimal_gsmc_ms.R
\name{redist_optimal_gsmc_ms}
\alias{redist_optimal_gsmc_ms}
\title{gSMC Redistricting Sampler (O'Sullivan, McCartan and Imai ???)}
\usage{
redist_optimal_gsmc_ms(
  state_map,
  M,
  counties = NULL,
  estimate_cut_k = TRUE,
  manual_k_params = 6,
  adapt_k_thresh = 0.9999,
  split_district_only = FALSE,
  weight_type = "optimal",
  ms_freq = 0,
  ms_steps_multiplier = 1L,
  run_ms = 0 < ms_freq && ms_freq <= ndists,
  merge_prob_type = "uniform",
  resample = TRUE,
  runs = 1L,
  ncores = 0L,
  multiprocess = TRUE,
  pop_temper = 0,
  init_region_ids_mat = NULL,
  init_dvals_mat = NULL,
  init_num_regions = 1,
  min_region_cut_sizes = NULL,
  max_region_cut_sizes = NULL,
  verbose = FALSE,
  silent = FALSE,
  diagnostic_mode = FALSE
)
}
\arguments{
\item{counties}{A vector containing county (or other administrative or
geographic unit) labels for each unit, which may be integers ranging from 1
to the number of counties, or a factor or character vector.  If provided,
the algorithm will only generate maps which split up to \code{ndists-1}
counties. Even there are fewer counties than \code{ndists - 1}, the spanning
trees will change the results of the simulations. There is no strength
parameter associated with this constraint. To adjust the number of county
splits further, or to constrain a second type of administrative split,
consider using \code{add_constr_splits()}, \code{add_constr_multisplits()}, and
\code{add_constr_total_splits()}.}

\item{adapt_k_thresh}{The threshold value used in the heuristic to select a
value \code{k_i} for each splitting iteration. Higher values are more accurate
but may require more computation. Set to 1 for the most conservative
sampling. Must be between 0 and 1.}

\item{resample}{Whether to perform a final resampling step so that the
generated plans can be used immediately.  Set this to \code{FALSE} to
perform direct importance sampling estimates, or to adjust the weights
manually.}

\item{runs}{How many independent parallel runs to conduct. Each run will
have \code{nsims} simulations. Multiple runs allows for estimation of simulation
standard errors. Output will only be shown for the first run. For
compatibility with MCMC methods, runs are identified with the \code{chain}
column in the output.}

\item{ncores}{How many cores to use to parallelize plan generation within each
run. The default, 0, will use the number of available cores on the machine
as long as \code{nsims} and the number of units is large enough. If \code{runs>1}
you will need to set this manually. If more than one core is used, the
sampler output will not be fully reproducible with \code{set.seed()}. If full
reproducibility is desired, set \code{ncores=1}.}

\item{multiprocess}{Whether or not to launch multiple processes (sometimes
better to disable to avoid using too much memory.)}

\item{pop_temper}{The strength of the automatic population tempering. Try
values of 0.01-0.05 to start if the algorithm gets stuck on the final few
splits.}

\item{verbose}{Whether to print out intermediate information while sampling.
Recommended.}

\item{silent}{Whether to suppress all diagnostic information.}

\item{k_params}{Either a single value to use as the splitting parameter for
every round or a vector of length ndists-1 where each value is the one to use for
a split.}
}
\value{
\code{redist_smc} returns a \link{redist_plans} object containing the simulated
plans.
}
\description{
\code{redist_gsmc} uses a Sequential Monte Carlo algorithm (O'Sullivan, McCartan and Imai ???)
to generate representative samples of congressional or legislative
redistricting plans according to contiguity, population, compactness, and
administrative boundary constraints.
}
\details{
This function draws samples from a specific target measure controlled by
the \code{map} parameters.
}

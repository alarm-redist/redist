% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/redist_generic_gsmc.R
\name{generic_redist_gsmc}
\alias{generic_redist_gsmc}
\title{gSMC Redistricting Sampler (O'Sullivan, McCartan and Imai ???)}
\usage{
generic_redist_gsmc(
  map,
  nsims,
  counties = NULL,
  compactness = 1,
  constraints = list(),
  runs = 1L,
  split_district_only = FALSE,
  weight_type = "optimal",
  sampling_space,
  splitting_method,
  splitting_params,
  ms_freq = 0,
  ms_steps_multiplier = 1L,
  run_ms = 0 < ms_freq && ms_freq <= ndists,
  merge_prob_type = "uniform",
  resample = TRUE,
  num_processes = 0L,
  num_threads_per_process = 0L,
  multiprocess = TRUE,
  pop_temper = 0,
  init_region_ids_mat = NULL,
  init_region_sizes_mat = NULL,
  custom_size_split_list = NULL,
  num_splitting_steps = NULL,
  ref_name = NULL,
  verbose = FALSE,
  silent = FALSE,
  diagnostic_mode = FALSE,
  counties_q = NULL,
  use_counties_q = F
)
}
\arguments{
\item{map}{A \code{\link[=redist_map]{redist_map()}} object.}

\item{nsims}{The number of samples to draw.}

\item{counties}{A vector containing county (or other administrative or
geographic unit) labels for each unit, which may be integers ranging from 1
to the number of counties, or a factor or character vector.  If provided,
the algorithm will only generate maps which split up to \code{ndists-1}
counties. Even there are fewer counties than \code{ndists - 1}, the spanning
trees will change the results of the simulations. There is no strength
parameter associated with this constraint. To adjust the number of county
splits further, or to constrain a second type of administrative split,
consider using \code{add_constr_splits()}, \code{add_constr_multisplits()}, and
\code{add_constr_total_splits()}.}

\item{compactness}{Controls the compactness of the generated districts, with
higher values preferring more compact districts. Must be nonnegative. See
the 'Details' section for more information, and computational
considerations.}

\item{constraints}{A \code{\link[=redist_constr]{redist_constr()}} object or a list containing
information on sampling constraints. See \link{constraints} for more information.}

\item{runs}{How many independent parallel runs to conduct. Each run will
have \code{nsims} simulations. Multiple runs allows for estimation of simulation
standard errors. Output will only be shown for the first run. For
compatibility with MCMC methods, runs are identified with the \code{chain}
column in the output.}

\item{split_district_only}{Whether or not to split plans by splitting off one
district at a time.}

\item{weight_type}{The type of SMC weights to use. Optimal weights typically
have lower variance but can be more computationally expensive, especially for
complex constraints or when sampling on the space of spanning forests.}

\item{sampling_space}{The space to sample the plans on. Right now the supported
options are graph partitions (graph_plan_space) and spanning
forests (spanning_forest_space)}

\item{splitting_method}{The method used for splitting spanning trees in the
sampling process. When sampling on the space of graph partitions it must be
the naive top k method but any method is allowed for forest space sampling.}

\item{splitting_params}{A list of parameters associated with the splitting
method passed in. Specific parameters depends on the splitting types}

\item{resample}{Whether to perform a final resampling step so that the
generated plans can be used immediately.  Set this to \code{FALSE} to
perform direct importance sampling estimates, or to adjust the weights
manually.}

\item{num_processes}{The number of processes (independent instances of R to
spawn) spawned to simulate the plans. The processes can execute runs in parallel}

\item{num_threads_per_process}{The number of threads assigned to each process.
This is the number of threads used when performing a specific run. If simulations
are memory constrained it can be better to lower the number of processes and increase
the threads per process.}

\item{multiprocess}{Whether or not to launch multiple processes (sometimes
better to disable to avoid using too much memory. NOTE: Non multiprocessing
appears to introduce validation bugs right now)}

\item{pop_temper}{The strength of the automatic population tempering. Try
values of 0.01-0.05 to start if the algorithm gets stuck on the final few
splits.}

\item{init_region_ids_mat}{A matrix of partial plans to begin sampling from. For
advanced use only.  The matrix must have \code{nsims} columns and a row for
every precinct. It is important to ensure that the existing districts meet
contiguity and population constraints, or there may be major issues when
sampling.}

\item{init_region_sizes_mat}{A matrix of region sizes of the partial plans to
begin sampling from. For advanced use only.  The matrix must have \code{nsims}
columns and at least as many rows as the number of regions in the
\code{init_region_ids_mat} and each column must sum to the number of seats in the
map.}

\item{num_splitting_steps}{How many steps to run the SMC algorithm for.
Each step splits off a new district. Defaults to all remaining districts.
If fewer than the number of remaining splits, reference plans are disabled.}

\item{ref_name}{a name for the existing plan, which will be added as a
reference plan, or \code{FALSE} to not include the initial plan in the
output. Defaults to the column name of the existing plan.}

\item{verbose}{Whether to print out intermediate information while sampling.
Recommended.}

\item{silent}{Whether to suppress all diagnostic information.}
}
\value{
\code{redist_gsmc} returns a \link{redist_plans} object containing the simulated
plans.
}
\description{
\code{generic_redist_gsmc} uses a Sequential Monte Carlo algorithm (O'Sullivan, McCartan and Imai ???)
to generate representative samples of congressional or legislative
redistricting plans according to contiguity, population, compactness, and
administrative boundary constraints.
}
\details{
Sampling can be performed either on the space of plans (graph partitions) or
on the space of spanning forests. This is an internal function designed to
support either sampling space and any arbitrary tree splitting method. The
functions \code{redist_gsmc} and \code{treedist_gsmc} are largely wrappers to calling
this function.

This function draws samples from a specific target measure controlled by
the \code{map} parameters.
}
\concept{simulate}
